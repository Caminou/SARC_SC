---
title: "R Notebook"
output: html_notebook
---

This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook. When you execute code within the notebook, the results appear beneath the code. 

Try executing this chunk by clicking the *Run* button within the chunk or by placing your cursor inside it and pressing *Ctrl+Shift+Enter*. 

### 2) Removal of ambient RNA using SoupX
```{r}

# to clean up the data by identifying and correcting for RNA contamination. These methods typically rely on distinguishing the actual cell expression profiles from background noise (ambient RNA) that may arise from dead cells, empty droplets, or cross-contamination.
#load libraries
library(SoupX)
library(Seurat)
#load seurat


library(future)

# Set higher limit
options(future.globals.maxSize = 2 * 1024^3)


### Create make_soup function:
# SoupX requires the raw_feature_bc_matrix from the CellRanger output (output with empty droplets!)
# Since we have renamed the barcodes in the previous steps, we will need to rename the barcodes in this raw_feature_bc_matrix

make_soup <- function(SARC_f) {
  library(dplyr)
  sample_id = unique(SARC_f$orig.ident) # get samples
  all_processed_counts <- list()
  for (sample in sample_id ){
    print(paste0("Reading ", sample))
    path <- paste0("/mnt/c/Users/caminorsm/Desktop/SARC/raw_feature_barcode_matrix/outs_raw/", sample)
    raw <- Read10X(data.dir = path)
    if (grepl("hSC26", sample)) {
      SARC_f_subset = subset(SARC_f, orig.ident %in% c("hSC26_AdjNorm","hSC26_ddLPS"))
      print(paste0("Normalizing"))
      SARC_f_subset    <- SCTransform(SARC_f_subset, verbose = F)
      print(paste0("DR"))
      SARC_f_subset    <- RunPCA(SARC_f_subset, verbose = F)
      SARC_f_subset    <- RunUMAP(SARC_f_subset, dims = 1:30, verbose = F)
      print(paste0("Clustering"))
      SARC_f_subset    <- FindNeighbors(SARC_f_subset, dims = 1:30, verbose = F)
      SARC_f_subset    <- FindClusters(SARC_f_subset, verbose = T)
      cell_names = as.data.frame(colnames(SARC_f_subset))
      print(paste0("Renaming barcodes"))
      colnames(cell_names)="cell_names"
      split_result= strsplit(cell_names$cell_names, "_")
      split_result <- sapply(split_result, `[`, 1)
      cell_names$barcode <- sapply(split_result, `[`, 3)
      raw = raw$`Gene Expression`
      new_colnames <- cell_names$cell_names[match(colnames(raw), cell_names$barcode)]
      colnames(raw)<- new_colnames
      # Remove cells not present in the filtered seurat object
      valid_cols <- !is.na(colnames(raw)) & colnames(raw) != "NA"
      raw_clean <- raw[, valid_cols]
      print(paste0("Seurat object contains: ", ncol(SARC_f_subset), "cells. Raw matrix contains", ncol(raw_clean), "cells."))
      common_genes = intersect(rownames(raw), rownames(SARC_f_subset@assays$RNA))
      raw_clean <- raw_clean[common_genes, , drop = FALSE]
    } else {
      SARC_f_subset= subset(SARC_f, orig.ident %in% sample)
      print(paste0("Normalizing"))
      SARC_f_subset <- SCTransform(SARC_f_subset, verbose = F)
      print(paste0("DR"))
      SARC_f_subset <- RunPCA(SARC_f_subset, verbose = F)
      SARC_f_subset    <- RunUMAP(SARC_f_subset, dims = 1:30, verbose = F)
      print(paste0("Clustering"))
      SARC_f_subset    <- FindNeighbors(SARC_f_subset, dims = 1:30, verbose = F)
      SARC_f_subset    <- FindClusters(SARC_f_subset, verbose = T)
      print(paste0("Renaming barcodes"))
      colnames(raw) = paste0(sample,"_", colnames(raw))
      # Remove cells not present in the filtered seurat object
      valid_cols <- colnames(SARC_f_subset)
      raw_clean <- raw[, valid_cols]
      print(paste0("Seurat object contains: ", ncol(SARC_f_subset), " cells. Raw matrix contains: ", ncol(raw_clean), " cells."))
      common_genes = intersect(rownames(raw), rownames(SARC_f_subset@assays$RNA))
      raw_clean <- raw_clean[common_genes, , drop = FALSE]
      print(paste0("Seurat object contains: ", nrow(SARC_f_subset), " genes. Raw matrix contains: ", nrow(raw_clean), " genes."))
    }
    # create soup channel by supplying the table of droplets (raw_feature_bc_matrix) and table of counts (filtered_feature_bc_matrix)
    meta    <- SARC_f_subset@meta.data
    umap    <- SARC_f_subset@reductions$umap@cell.embeddings
  sc = SoupChannel(raw_clean,SARC_f_subset@assays[["RNA"]]@layers[[1]])
  sc = setClusters(sc, setNames(meta$seurat_clusters, rownames(meta)))
  sc <- setDR(sc,umap)
  sc = autoEstCont(sc)
  head(sc$soupProfile[order(sc$soupProfile$est, decreasing = T), ], n = 20)
  out = adjustCounts(sc, roundToInt = TRUE)
  #optional keep original counts
  all_processed_counts[[sample]] <- out
  SARC_f[[paste0("processed_counts_", sample)]] <- CreateAssayObject(counts = out)
  }
  return(SARC_f)
  
}

SARC_f = make_soup(SARC_f)

```

Add a new chunk by clicking the *Insert Chunk* button on the toolbar or by pressing *Ctrl+Alt+I*.

When you save the notebook, an HTML file containing the code and output will be saved alongside it (click the *Preview* button or press *Ctrl+Shift+K* to preview the HTML file).

The preview shows you a rendered HTML copy of the contents of the editor. Consequently, unlike *Knit*, *Preview* does not run any R code chunks. Instead, the output of the chunk when it was last run in the editor is displayed.
